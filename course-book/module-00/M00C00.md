# Python Functional Programming Deep Dive

## **Module 01: Functions as Values and Pure Building Blocks**

01. Functional vs Imperative Mental Model (Substitution, No Hidden State)
02. Pure Functions & Contracts (Inputs, Outputs, No Shared Mutation)
03. Immutability & Value Semantics in Python (tuples, frozenset, frozen dataclass)
04. Higher-Order Functions & Composition (pipe, compose, Callable/typing)
05. Local FP Refactorings (Replace In-Place Loops with Small Pure Transforms)
06. Small Combinator Libraries (map/filter-Style Helpers and Custom `pipe` Abstractions)
07. Type-Hinted Pure Functions and Higher-Order Pipelines (TypeVar, ParamSpec, Concatenate)
08. Extracting Side Effects – Passing Dependencies Explicitly Instead of Touching Globals
09. Equational Reasoning and Local Rewrite Rules for Pure Code
10. Idempotent and Monotone Transforms (Stability Under Repeated Application)

## **Module 02: Closures, Expressions, and FP-Friendly APIs**

01. Closures & Partial Application (functools.partial as Configurators)
02. Expression-Oriented Python (Comprehensions, Conditional Expressions, No Control Flags)
03. Intro to Laziness with Simple Generators (Why “Don’t Build the List”)
04. Designing FP-Friendly APIs (Small Arity, Explicit Parameters, No Hidden Globals)
05. Boundary Design – Where Side Effects Are Allowed (I/O Edges Only)
06. Configuration-as-Data (dataclasses/dicts + Partial Application for Behaviour)
07. Callback Hell to Combinators – Replacing Callbacks with Clear Functional Pipelines
08. Tiny Function DSLs – Using Functions + Data to Express Domain Rules
09. Debugging FP Code (Naming, Probing, and Tracing Intermediate Steps in Compositions)
10. Refactoring Imperative Scripts into FP-Friendly Modules and APIs

## **Module 03: Iterator Protocol and Lazy Dataflow**

1. Iterator Protocol & Generator Functions
2. Generator Expressions vs List Comprehensions (Memory & Readability)
3. Composing Iterators with itertools (chain, islice, groupby, tee)
4. Chunking, Windowing, Grouping – Streaming Aggregations
5. Infinite & Unbounded Sequences (Fencing with islice, takewhile)
6. Building Reusable Iterator-Based FuncPipe Stages (Reusable Pipelines, Not One-Off Scripts)
7. Fan-In and Fan-Out for Streams (Merging, Splitting, and Multicasting Iterators Safely)
8. Time-Aware Streaming Patterns (Throttling and Simple Rate-Limiting in Pure Style)
9. Designing Custom Iterator Types (Classes Implementing `__iter__` / `__next__`)
10. Observability for Streams (Counting, Sampling, and Tapping Pipelines Without Breaking Laziness)

## **Module 04: Recursion, Folds, Memoization & Streaming Failures**

1. Structural Recursion vs Iteration in Python (Pragmatic Limits)
2. Folds & Reductions as “Safe Recursion” (reduce, accumulate, Custom Folds)
3. Memoization & Caching of Pure Functions (lru_cache and Custom Caches)
4. Result/Option Types for Per-Record Failures (Simple FP Error Containers)
5. Streaming Error Handling – Mixed Good/Bad Data in a Single FuncPipe
6. Error Aggregation Strategies – Fail-Fast vs Error-List Accumulation for Streams
7. Short-Circuiting and Circuit-Breaker Behaviour via Pure Result Types
8. Resource-Aware Streaming – Ensuring Generators Close and Clean Up Correctly
9. Functional Retries in Streaming Contexts (Policies as Data, Execution as Pure Loops)
10. Building Structured Error Reports from Streaming Pipelines (Errors as First-Class Data)

## **Module 05: Algebraic Data Modelling**

1. Product & Sum Types via dataclasses, Enum, Union
2. Modelling Domain States (Success/Failure, Pending/Running/Done) as ADTs
3. Functors in Python – “Things You Can Map Over” (Option, Result, List)
4. Applicative Patterns for Independent Validation (Collect All Errors)
5. Monoids & Semigroups for Aggregation (Logs, Metrics, Configs)
6. Smart Constructors with Pydantic v2 – Runtime Enforcement and Serialization (model_validator, Discriminated Unions, computed_field)
7. Pattern Matching in Python 3.10+ for ADTs (Using `match` with Structured Types)
8. ADTs and Serialization Beyond Pydantic (Plain dataclasses, Marshmallow, Custom Codecs)
9. Compositional Domain Models – Splitting and Combining ADTs Across Subsystems
10. Performance and Ergonomics of ADT-Heavy Designs (When to Compromise)

## **Module 06: Monadic Flows as Composable Pipelines**

1. `bind` / `and_then` Patterns for Result/Option Pipelines
2. Law-Guided Design – Identity & Associativity Checks with Hypothesis
3. Lifting Plain Functions into Containers (map, apply, bind Helpers)
4. Reader-Like Pattern for Configuration (Functions of Config, Partial Injection)
5. Minimal State-Like Pattern via Explicit State Threading (No Globals)
6. Error-Typed Flows – Separating Expected Domain Errors from Unexpected Failures
7. Layering Containers Without Category-Theory Overload (Simple “Stacked” Pipelines)
8. Tracing and Logging in Monadic Pipelines (Side-Effect-Free Instrumentation)
9. Refactoring `try/except` Spaghetti into Result/Option-Based Pipelines
10. Configurable Pipelines via Higher-Order Combinators (Toggle Validation, Logging, Metrics)

## **Module 07: Effect Boundaries & Resource Safety**

1. Ports & Adapters – Pure Domain, Effectful Infrastructure
2. Effect Interfaces – `returns`, `effect`, and Stdlib Alternatives for Representing IO/Task
3. Designing Effect Interfaces as Pure Protocols (Storage, Clock, Logger)
4. Context Managers & Resource Safety (contextlib and Nested Resources)
5. Functional Logging & Tracing (Logs as Data, Monoidal Accumulation)
6. Effect Capabilities and Static Checking with Protocols + `mypy --strict`
7. Composing Effects – Building Larger Behaviour from Small Capability Interfaces
8. Idempotent Effect Design for Safe Retries and Replays
9. Sessions and Transactions as Explicit Data and Functions (Not Hidden Globals)
10. Incremental Migration – Pushing Side Effects Outwards in Existing Codebases

## **Module 08: Async FuncPipe & Backpressure (Concurrency Lite)**

1. async/await as Descriptions of Steps, Not Hidden Magic
2. Async Generators & Streams – Building Async FuncPipe
3. Bounded Queues & Backpressure – Preventing Memory Blowups
4. Retry & Timeout Policies as Pure Data Fed into Async Steps
5. Testing Async Functional Pipelines Deterministically (Fake Time/Executors)
6. Rate Limiting and Fairness in Async Functional Streams
7. Integrating Pure FuncPipe Core with Async Edges Cleanly
8. Designing Async Adapters for External Services (HTTP, DB) from Pure Interfaces
9. Time-Based and Size-Based Chunking Strategies in Async Pipelines
10. Law-Like Properties for Async Pipelines (Idempotence, At-Most-Once, No Duplication)

## **Module 09: FP Across Libraries and Frameworks**

1. FP in Stdlib – itertools, functools, operator, pathlib
2. FP Helper Libraries – `toolz` / `returns` in Real Pipelines
3. Data Processing – Pandas/Polars/Dask in FP Style (Pure Transforms, Method Chains vs Pipelines)
4. Web and Services – FastAPI Endpoints with Pure Core & Thin Adapters
5. Data/ML Pipelines – Stateless Transforms, Config-Driven FuncPipe Steps
6. Command-Line and Config-Driven FuncPipe – Integrating with Click/Typer
7. FP Style with Distributed/Dataflow Systems (Dask/Beam-Like Transform + Sink Thinking)
8. Wrapping Imperative Libraries in Functional Facades (Normalizing Side-Effectful APIs)
9. Cross-Process Composition – Serializing Configs/Specifications, Not Live Objects
10. Team Adoption – Coding Standards, Patterns, and Review Guidelines for FP-Style Python

## **Module 10: Refactoring, Performance, and Future-Proofing**

1. Systematic Refactor – Imperative Spaghetti → Layered FuncPipe (Step-by-Step)
2. Performance Budgeting – When FP Wins, When to Vectorize, When to Drop to C/NumPy
3. Observability – Tracing Through Pure Pipelines, Debuggable Composition
4. Property-Based Regression & Invariant Testing for Pure Pipelines (Hypothesis in CI)
5. Property-Based Testing for Async and Streaming Pipelines (Hypothesis Strategies and Faked I/O)
6. Future Directions – Pattern Matching, Typing Advances, Next-Step Parallel FuncPipe
7. Domain-Driven Design Meets FP – Aligning Bounded Contexts with Pipelines
8. Versioning and Migration of FuncPipe Contracts and Pipeline Graphs
9. Governance – Ownership, Change Control, and “Unsafe” Extensions of FuncPipe
10. Capstone — Proving, Shipping, and Sustaining a FuncPipe System
